import random
import string
import phonenumbers as pn
import datetime
import pytz
import importlib
import shortuuid
import magic
from dateutil.relativedelta import relativedelta

from misc import get_countires

django_found = importlib.find_spec('django') is not None
utc = pytz.UTC


###################
# RANDOM GENERATORS
def gen_n_digit_string(n):
    numbers = string.digits
    return ''.join(random.SystemRandom().choice(numbers) for _ in range(n))


def generate_initials(name, max_initials=2):
    """
    Generates initials for a person's or organization's name.

    Name can be a string or list. If inputted as a list, input names in desired order of
    initials, such as [first, last]. If an element of that list has multiple names
    (e.g. a middle name or multiple last names), those names will also be taken into account.
    """
    if not name:
        return None

    if isinstance(name, str):
        name_split = name.split(' ', max(max_initials - 1, -1))
        name_split.insert(0, '_recursive')
        initials = generate_initials(name_split, max_initials)
    elif isinstance(name, list):
        if name[0] == '_recursive':
            del name[0]
        else:
            name = ' '.join(name).split(' ', max(max_initials - 1, -1))

        if len(name) > 1:
            initials = name.pop(0)[0]
            s_n = name.pop(-1)[0]
            name_count = 2

            if initials:
                for s in name:
                    if name_count < max_initials - 1:
                        initials += s[0]
                        name_count += 1
                    else:
                        break

            if name_count <= max_initials:
                initials += s_n
        else:
            initials = name[0][0]

        initials = initials.upper()
    else:
        raise Exception("Name must be a string or a list of strings.")

    return initials


def password_gen(string_length=16):
    mixup = string.ascii_letters + string.digits
    return ''.join(random.choice(mixup) for _ in range(string_length))


def shorter_uuid(length=7, starter=None, with_original=False):
    """
    Generate an even shorter short UUID generated by the shortuuid library.

    :param length: Length of trimmed ID.
    :param starter: Whether to begin with an already-created ShortUUID.
                    Useful when using recursively.
    :param with_original: Also return initially-generated ShortUUID
    :return:
    """
    original_id = str(shortuuid.uuid()) if starter is None else starter
    n = len(original_id)
    dx = min(length, len(original_id))  # ID length
    if starter is not None and len(starter) < dx * 2:
        original_id = str(shortuuid.uuid())

    start_point = random.randint(0, n - dx)
    shorter_id = original_id[start_point:(start_point + dx)]

    return shorter_id if not with_original else [shorter_id, original_id]


###############################
# CONTACT INFORMATION FUNCTIONS
def prettify_phone(phone, country='CA', with_country_code=False, no_fail=True):
    phone_obj = pn.parse(phone, country)
    fmt = pn.PhoneNumberFormat.NATIONAL if not with_country_code else pn.PhoneNumberFormat.INTERNATIONAL

    if no_fail:
        try:
            result = pn.format_number(phone_obj, fmt)
        except (TypeError, ValueError, ValidationError):
            result = phone
    else:
        result = pn.format_number(phone_obj, fmt)

    return result


####################################
# DATE, TIME, AND DATETIME FUNCTIONS
def local_datetime(dt=None, tz=None):
    if dt is None:
        if django_found:
            from django.utils.timezone import now
            dt = now()
        else:
            dt = datetime.datetime.now(tz=utc)

    try:
        dt = utc.localize(dt=dt)
    except ValueError:
        # Datetime is already localized
        pass

    if django_found:
        from django.utils.timezone import localtime
        return localtime(dt)
    else:
        if tz is not None:
            if isinstance(tz, str):
                tz = pytz.timezone(tz)

            return dt.replace(tzinfo=tz)
        else:
            return dt


def time_of_day(time):
    if not isinstance(time, (datetime.datetime, datetime.time)):
        raise TypeError("Variable 'time' must be datetime.datetime or datetime.time object.")

    if 4 <= time.hour < 12:
        return 'morning'
    elif 12 <= time.hour < 18:
        return 'afternoon'
    elif 18 <= time.hour < 24 or 0 <= time.hour < 4:
        return 'evening'


def get_midnight(dt: datetime.datetime):
    return datetime.datetime.combine(dt, datetime.datetime.min.time())


def get_datetime_range(dt: datetime.datetime):
    """
    Converts a datetime object to an upper and lower limit of datetimes (midnight to midnight).
    :param dt: A datetime **date** object.
    :return: A list of the lower and upper datetimes.
    """
    # Convert to date and back to datetime to obtain midnight
    dt = dt.date()
    dt_lower = datetime.datetime.combine(dt, datetime.min.time())
    dt_upper = dt + relativedelta(days=1)
    dt_lower = datetime.datetime.combine(dt_lower, datetime.min.time())
    dt_upper = datetime.datetime.combine(dt_upper, datetime.min.time())

    return [dt_lower, dt_upper]


def date_to_datetime(date_obj: date = None) -> datetime:
    """
    Convert date object to midnight datetime object. No input convert's today's date.
    """
    if date_obj is None:
        return datetime.combine(datetime.now().date(), datetime.min.time())
    else:
        return datetime.combine(date_obj, datetime.min.time())


def parse_datetime(in_put, as_date: bool = False, preserve_time: bool = True, tz=None, str_format: str = '%Y-%m-%d'):
    """
    Parse a variety of formats to a date() or datetime() object.

    :param in_put: The input to parse. Can be int (timestamp), str (datetime string), or even date()/datetime().
    :param as_date: Return a date() object rather than datetime().
    :param preserve_time: Only applicable if as_date=False. If False, will return datetime(date, midnight)
    :param tz: Adds a timezone to the result. Can be a str (timezone's name) or a pytz object.
    :param str_format: Only applicable if in_put is str. Must be the datetime format of in_put.
        Refer to https://devhints.io/strftime for datetime formats.
    :return: datetime(), date(), or None
    """
    default_format = '%Y-%m-%d'
    o = None
    if isinstance(in_put, int):
        try:
            o = datetime.fromtimestamp(in_put)
        except ValueError:
            in_put /= 1000
            try:
                o = datetime.fromtimestamp(in_put)
            except ValueError:
                pass
    elif isinstance(in_put, str):
        try:
            o = datetime.strptime(in_put, str_format)
        except ValueError:
            if str_format != default_format:
                try:
                    o = datetime.strptime(in_put, default_format)
                except ValueError:
                    pass
    else:
        if isinstance(in_put, (datetime.date, datetime.datetime)):
            o = in_put

    if o:
        if tz:
            if isinstance(o, date):
                o = date_to_datetime(o)
            o = pytz.timezone(tz).localize(dt=o) if isinstance(tz, str) else tz.localize(dt=o)

        if as_date:
            if not isinstance(o, date):
                o = o.date()
        else:
            if not preserve_time:
                o = date_to_datetime(o.date())

    return o


###########################
# MAILING ADDRESS FUNCTIONS
def address_case(address):
    """
    Title-cases a mailing address except for its ordinals, i.e. 'nd', 'rd', 'st', 'th'.
    :param address: A standard physical address.
    :return: A properly title-cased address.
    """
    result = ''
    directions = ['N', 'S', 'E', 'W', 'NW', 'NE', 'SW', 'SE']

    address_split = address.split()

    for i in range(len(address_split)):
        curr = address_split[i]
        curr = curr.upper() if curr in directions else curr.capitalize()
        result += curr

        if i < len(address_split) - 1:
            result += ' '

    # Extra measure to strip text just in case
    result.strip()

    return result


def prettify_address(address_1, city, provstate, postcode, address_2=None, country=None, one_line=False, as_list=False):
    address_string = f"{address_1}" if not address_2 else f"{address_2}-{address_1}"

    if country:
        # Get full name of country if inputted as country code
        country = get_countries().get(country, country)

    if provstate in dict(get_provinces()) and ' ' not in postcode:
        postcode = f"{postcode[:3]} {postcode[3:]}"

    if not one_line:
        if not as_list:
            address_string += '\n'
            address_string += f"{city}, {provstate}\n"
            address_string += postcode
            if country:
                address_string += f"\n{country}"
        else:
            address_list = [address_string, f"{city}, {provstate}", postcode]
            if country:
                address_list.append(country)

            return address_list
    else:
        address_string += f", {city}, {provstate}  {postcode}"
        if country:
            address_string += f", {country}"

    return address_string


def address_cleaner(address_1: str, city: str, provstate: str, postcode: str,
                    address_2: str = None, country: str = None):
    """
    Converts North American mailing address to title-case,
    except for its ordinals, i.e. 'nd', 'rd', 'st', 'th'.

    :param address_1: Street address
    :param address_2: Suite, apartment, etc.
    :param city: City name
    :param provstate: Province or State
    :param postcode: Postal Code
    :param country: Country (optional)
    :return:
    """
    result = list()

    if address_2 is None or (address_2 is not None and address_2 == ''):
        address_2 = ''

    if country is None or (country is not None and country == ''):
        country = None

    if len(provstate) > 2:
        raise Exception('Expected two-letter abbreviation for province or state.')

    address_1_split = address_1.split()
    address_2_split = address_2.split()

    for address in [address_1_split, address_2_split]:
        temp = ''

        if len(address) > 0:
            for i in range(len(address)):
                if i != len(address) - 1:
                    temp += address[i].capitalize() + ' '
                else:
                    temp += address[i].capitalize()

            temp.strip()  # Extra measure just in case
            result.append(temp)
        else:
            result.append(None)

    result.extend([city.title(), provstate.upper(), postcode.upper().replace(' ', '')])

    if country is not None:
        result.append(country.title())

    return result


def propercase_name(name: str):
    name = name.title()

    if "'" in name:
        split = name.split("'")
        start_capitalizing_at = 0

        if len(split[0]) < 2:
            # e.g. l', d'
            split[0] = split[0].lower()
            start_capitalizing_at += 1

        # Capitalize what is necessary
        [split[x].title() for x in range(start_capitalizing_at, len(split))]

        name = "'".join(split)
    else:
        if name[0:2].casefold() == 'mc':
            name = replace_at_index(name, name[2].upper(), 2, True)
        elif name[0:2].casefold() == "o'":
            idx_to_replace = 2 if name[2] != ' ' else 3
            name = replace_at_index(name, name[idx_to_replace].upper(), idx_to_replace, True)
        elif name[0:3].casefold() == 'mac':
            name = replace_at_index(name, name[3].upper(), 3, True)
        elif name[0:3].casefold() == 'de ':
            p1 = 'de '
            p2 = name.split('de ', 1)[1]
            p2 = propercase_name(p2)
            name = p1 + p2
        elif name[0:4].casefold() in ['van ', 'der ']:
            p1 = name[0:4].lower()
            p2 = name.split(p1, 1)[1]
            p2 = propercase_name(p2)
            name = p1 + p2
        else:
            return name

    return name


def replace_at_index(stringue: str, new_char: str, index: int, no_fail: bool = False):
    """
    Replace a string's character at the specified index.

    :param stringue: The original string.
    :param new_char: The new character(s).
    :param index: The index whose character you want to replace.
    :param no_fail: If True, silently fail and return original string.
    :return: A new string with the change applied.
    """
    n = len(stringue)
    if index not in range(n):
        if not no_fail:
            raise ValueError(f"Index out-of-bounds. Must be 0 < index ≤ {len(stringue)}.")
        else:
            return stringue

    max_index = n - 1

    new_string = stringue[:index] + new_char
    if index < max_index:
        new_string += stringue[index + 1:]

    return new_string


######
# URLs
def check_if_slug_nonempty(slug):
    """
    Raise a 404 Error if the required slug(s) of a page's querystring is/are not present.
    """
    if isinstance(slug, list):
        for i in slug:
            if i is None:
                raise Http404()
    else:
        if slug is None:
            raise Http404()


def url_has_param(url, param):
    """Checks whether a URL contains specified parameter."""
    url = str(url)
    return any(x in url for x in [f'?{param}=', f'&{param}='])


def add_url_param(url, param_key, param_value):
    """Adds a new parameter to specified URL."""
    url = str(url)
    url_split = url.split('?')
    separator = '&' if len(url_split) > 1 else '?'
    url += separator + param_key + '=' + param_value

    return url


def encode_url_param(p):
    return quote(str(p).encode(encoding='utf-8'))


#######
# FILES
def check_file_type(file, file_type):
    file_type = file_type.casefold()  # Convert to lowercase

    # Remove dot(s) from file_type
    if '.' in file_type:
        file_type = file_type.replace('.', '')

    # Create dictionary of common MIME types
    mimetypes = {
        'csv': 'text/csv',
        'doc': 'application/msword',
        'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'js': 'text/javascript',
        'json': 'application/json',
        'png': 'image/png',
        'pdf': 'application/pdf',
        'ttf': 'font/ttf',
        'txt': 'text/plain',
        'xls': 'application/vnd.ms-excel',
        'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'zip': 'application/zip',
    }

    additional_mimetypes = {
        'csv': ['application/csv']
    }

    for key in ['jpg', 'jpeg']:
        mimetypes[key] = 'image/jpeg'

    mime = magic.Magic(mime=True)
    mimetype = mimetypes.get(file_type)
    extra_mimetypes = additional_mimetypes.get(file_type)
    file_mimetype = mime.from_buffer(file.read()).casefold()

    if mimetype and (file_mimetype == mimetype or
                     (extra_mimetypes and isinstance(extra_mimetypes, list)
                      and any(file_mimetype == x for x in extra_mimetypes))):
        file.seek(0)
        return True
    else:
        raise FileTypeException(file_type)


class FileTypeException(Exception):
    """
    Error(s) related to file uploads.
    """

    def __init__(self, file_type, error_code=1, show_error_code=False):
        messages = {
            1: f"Files must be .{file_type} or .{file_type.upper()}.",
        }

        self.show_error_code = show_error_code
        self.error_code = error_code
        self.message = messages.get(1) if self.error_code not in messages.keys() else messages.get(self.error_code)
        super().__init__(self.message)

    def __str__(self):
        return f"Error {self.error_code}: {self.message}" if self.show_error_code else f"Error: {self.message}"


######
# MISC
def is_email(email: str):
    """Checks whether or not the inputted string as an email address."""
    return re.match(r"[^@]+@[^@]+\.[^@]+", email)


def class_name(obj):
    """
    Returns lowercase class name of any object's class, especially that of a Django model instance.
    """
    return obj.__class__.__name__.casefold()


def is_stringified_list(s):
    """
    Checks whether string is a list using JSON.

    TIP: In JSON, strings are only characterized by double quotation marks.
         I.e., "animal" is a valid string in JSON, whereas 'animal' is not.

    :param s: An arbitrary string.
    """
    return isinstance(json.loads(s), list) if not s else False


def json_dumps_b64(i, url_safe=True):
    """
    Convert a Python literal to a base64 representation of JSON string.

    :param i: A list, dict, int, str, bool, or None.
    :param url_safe: Whether to encode for use in a URL query string.
    :return: A base64 representation of a JSON string.
    """
    o = json.dumps(i, cls=CustomEncoder)
    o = o.encode(encoding='UTF-8')
    o = base64.b64encode(o) if not url_safe else base64.urlsafe_b64encode(o)
    o = o.decode(encoding='UTF-8')

    return o


def json_loads_b64(i: str, url_safe=False):
    """
    Convert a base64 representation of a JSON string to a Python literal.

    :param i: A string
    :param url_safe: Whether the input string was made to be safe for use in a URL.
    :return: A Python literal.
    """
    if not isinstance(i, str):
        i = str(i)

    o = i.encode(encoding='UTF-8')
    o = base64.b64decode(o) if not url_safe else base64.urlsafe_b64decode(o)
    o = json.loads(o, object_hook=object_hook)

    return o


def verbose_list_to_list(stringue: str, as_string=False):
    """
    Convert a verbose list, such as "a, b, c", "a / b / c", "a/b/c", etc. into a Python list.

    :param stringue: A string input
    :param as_string: If true, function returns a JSON string rather than a list.
    :return: list or str, depending on as_str
    """
    separators = [' / ', '/', ', ', ',', '+', '*']

    already_separated = False
    result = None
    i = 0
    while not already_separated and i < len(separators):
        sep = separators[i]
        if sep in stringue:
            # Convert string to list of strings if multiple elements are present
            good_to_split = True

            if good_to_split and sep == '/':
                idx = stringue.index(sep)
                if 0 < idx < len(stringue):
                    before = stringue[idx - 1]
                    after = stringue[idx + 1]

                    if all(x in numbers_string for x in [before, after]):
                        good_to_split = False

                    temp_split = stringue.split(sep)
                    if len(temp_split) == 2 and all(len(x) == 1 for x in temp_split):
                        # e.g. C/V
                        good_to_split = False

            if good_to_split:
                result = stringue.split(sep)
                already_separated = True

        i += 1

    return result if not as_string else json.dumps(result)
